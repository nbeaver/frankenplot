#!/usr/bin/env python

# Name: frankenplot
# Purpose: Quick 'n dirty plotting of MRCAT XRF mapping data
# Author: Ken McIvor <mcivor@iit.edu>
#
# Copyright 2006-2009 Illinois Institute of Technology
#
# Permission is hereby granted, free of charge, to any person obtaining
# a copy of this software and associated documentation files (the
# "Software"), to deal in the Software without restriction, including
# without limitation the rights to use, copy, modify, merge, publish,
# distribute, sublicense, and/or sell copies of the Software, and to
# permit persons to whom the Software is furnished to do so, subject to
# the following conditions:
#
# The above copyright notice and this permission notice shall be
# included in all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL ILLINOIS INSTITUTE OF TECHNOLOGY BE LIABLE FOR ANY
# CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
# TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
# SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#
# Except as contained in this notice, the name of Illinois Institute
# of Technology shall not be used in advertising or otherwise to promote
# the sale, use or other dealings in this Software without prior written
# authorization from Illinois Institute of Technology.

# ChangeLog
#
# 12-06-2006  Ken McIvor <mcivor@iit.edu>
#  * Release 1.0
#
# 02-21-2007  Ken McIvor <mcivor@iit.edu>
#  * Release 1.1
#  * Matplotlib 0.87.7 compatability fixes
#
# 04-15-2007  Ken McIvor <mcivor@iit.edu>
#  * Release 1.2
#  * Incorporated Bruce Ravel's patch, adding an "-m" option for specifying
#    the color map
#
# 03-06-2008  Ken McIvor <mcivor@iit.edu>
#  * Release 1.3
#  * Reverted to the pre-0.81 axes formatters
#    the color map
#
# 02-20-2008  Ken McIvor <mcivor@iit.edu>
#  * Release 1.4
#  * WxMpl is now imported before matplotlib to avoid the warning "This call
#    to matplotlib.use() has no effect because the the backend has already
#    been chosen"


import wx
import wxmpl
import matplotlib.cm
import matplotlib.numerix as nx
import optparse
import os.path
import pylab
import re
import sys
import xdp.io


__version__ = '1.3'


def getNumberUnique(vect):
    """
    Return the number of times elements appear in the vector 'vect' without
    repeating the first element of the vector.

    This only works for vectors like '[0, 1, 2, 3, 0, 1, 2, 3]'.
    """
    i = 1
    num = 0
    start = vect[0]
    max = vect.shape[0]
    while i < max:
        if vect[i] == start:
            break
        else:
            i += 1
    return i


def makeXYZ(xCol, yCol, zCol):
    idxs = nx.arange(0, zCol.shape[0], 1)
    nX = getNumberUnique(xCol)
    if nX == 1: # Y varies: (0, 0, z), (0, 1, z), ...
        nY = getNumberUnique(yCol)
        nX = int(nx.ceil(yCol.shape[0] / float(nY)))
        y = yCol[0:nY]
        x = getUniqueSequence(xCol, nX)
        z = nx.zeros((nY, nX), nx.Float)
        z[:, :] = nx.minimum.reduce(zCol)
        for i in range(0, nX):
            zc = zCol[nY*i:nY*(i+1)]
            n  = zc.shape[0]
            z[0:n,i] = zc
    else: # X varies: (0, 0, z), (1, 0, z), ...
        nY = int(nx.ceil(xCol.shape[0] / float(nX)))
        x = xCol[0:nX]
        y = getUniqueSequence(yCol, nY)
        z = nx.zeros((nY, nX), nx.Float)
        z[:, :] = nx.minimum.reduce(zCol)
        for i in range(0, nY):
            zc = zCol[nX*i:nX*(i+1)]
            n  = zc.shape[0]
            z[i, 0:n] = zc
    return x, y, z


def getUniqueSequence(vect, count):
   """Return a Numeric array containing the at most the first 'count' unique
   elements from the vector 'vect'.

   The 'vect' must contain at least one element.

   This only works for vectors like '[0, 0, 1, 1, 2, 2, 3, 3]'.
   """
   i = 0
   curr = None
   unique = []
   max = vect.shape[0]

   while i < max:
       if vect[i] == curr:
           i += 1
       else:
           if len(unique) == count:
               break
           else:
               curr = vect[i]
               unique.append(curr)
               i += 1

   return nx.array(unique)


def fatal_error(msg, *args):
    if args:
        print >> sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]),
            (msg % args))
    else:
        print >> sys.stderr, '%s: %s' % (os.path.basename(sys.argv[0]), msg)
    sys.exit(1)


def parse_arguments(args):
    # matplotlib's color maps
    colormaps = ['autumn', 'bone', 'cool', 'copper', 'flag', 'gray', 'hot',
        'hsv', 'pink', 'prism', 'spring', 'summer', 'winter']

    USAGE = '%prog [OPTIONS...] FILE [ROI-NUMBER]'
    VERSION = '%prog ' + __version__ + ', by Ken McIvor <mcivor@iit.edu>'
    parser = optparse.OptionParser(usage=USAGE, version=VERSION)

    parser.add_option('-i',
        action='store', type='string', dest='IoName', default='Io',
        help='Io column name ("Io" is default)', metavar='N')

    parser.add_option('-x',
        action='store', type='string', dest='xName', default='sam_hor',
        help='x-axis column name ("sam_hor" is default)', metavar='N')

    parser.add_option('-y',
        action='store', type='string', dest='yName', default='sam_vert',
        help='y-axis column name ("sam_vert" is default)', metavar='N')

    parser.add_option('-n',
        action='store_false', dest='normalize', default=True,
        help='disable Io normalization')

    parser.add_option('-m',
        action='store', dest='colormap', default='hot',
        help=('color map (%s)' % ', '.join(colormaps)), metavar='C')

    opts, args = parser.parse_args(args)
    if not 0 < len(args) < 3:
        parser.print_usage()
        sys.exit(1)

    fileName  = args[0]
    roiNumber = 0
    if len(args) == 2:
        try:
            roiNumber = int(args[1])
        except ValueError:
            fatal_error('invalid ROI number "%s"', repr(args[1])[1:-1])

        if roiNumber < 0:
            fatal_error('invalid ROI number "%s"', repr(args[1])[1:-1])

    cm = opts.colormap.lower()
    if cm not in colormaps:
        fatal_error('invalid color map "%s"', opts.colormap)
    else:
        opts.colormap = cm

    return opts, (fileName, roiNumber)


def main(opts, args):
    fileName, roiNumber = args

    # load the data file
    try:
        hdr, data = xdp.io.readFile(fileName)
    except IOError, e:
        if e.strerror:
            fatal_error('could not load `%s\': %s', fileName, e.strerror)
        else:
            fatal_error('could not load `%s\': %s', fileName, e)

    # fetch x
    try:
        xCol = data.getColumn(opts.xName)
    except xdp.ColumnNameError:
        fatal_error('invalid x-axis column name "%s"', repr(opts.xName)[1:-1])

    # fetch y
    try:
        yCol = data.getColumn(opts.yName)
    except xdp.ColumnNameError:
        fatal_error('invalid x-axis column name "%s"', repr(opts.xName)[1:-1])

    # find the corrected ROIs
    roipat = re.compile('corr_roi[0-9]+_%d' % roiNumber)
    rois   = [x for x in data.getColumnNames() if roipat.match(x) is not None]
    if not rois:
        fatal_error('`%s\' contains no data for ROI %d',
            os.path.basename(fileName), roiNumber)

    # calculate z
    zExpr = '+'.join(['$'+x for x in rois])
    if opts.normalize:
        if data.hasColumn(opts.IoName):
            zExpr = '(%s)/$%s' % (zExpr, opts.IoName)
        else:
            fatal_error('invalid Io column name "%s"', repr(opts.IoName)[1:-1])
    zCol = data.evaluate(zExpr)
    x, y, z = makeXYZ(xCol, yCol, zCol)

    # construct the GUI
    fnam = os.path.basename(fileName)
    app = wxmpl.PlotApp(fnam + ' - PlotMap')

    # setup the axes
    fig = app.get_figure()
    axes = fig.gca()

    if matplotlib.__version__ >= '0.81':
        axes.yaxis.set_major_formatter(
            matplotlib.ticker.OldScalarFormatter())
        axes.yaxis.set_major_locator(
            matplotlib.ticker.LinearLocator(5))

        axes.xaxis.set_major_formatter(
            matplotlib.ticker.OldScalarFormatter())
        axes.xaxis.set_major_locator(
            matplotlib.ticker.LinearLocator(5))

    axes.set_title('ROI %d of %s' % (roiNumber, fnam))
    axes.set_xlabel(opts.xName)
    axes.set_ylabel(opts.yName)

    # plot the data and colorbar
    extent = min(x), max(x), min(y), max(y)
    img = axes.imshow(z, cmap=getattr(matplotlib.cm, opts.colormap),
            origin='lower', aspect='equal', interpolation='nearest',
            extent=extent)
    cb = fig.colorbar(img, cax=None, orientation='vertical')

    # run the GUI
    app.MainLoop()


if __name__ == '__main__':
    try:
        opts, args = parse_arguments(sys.argv[1:])
        main(opts, args)
    except KeyboardInterrupt:
        pass
